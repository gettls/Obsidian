# 추상화 레벨

통상적으로 ==추상화 레벨==에 대해서 이야기 할 때, 물리 장치로부터 멀어질 때 ==높은 레벨==이라고 이야기한다. 높은 레벨의 언어일수록 단순함을 얻지만, 통제력을 잃어간다고 볼 수 있다.

#### 추상화 레벨의 통일

CS 에서 그렇듯이 코드에서도 추상화 레벨을 구분할 수 있다. 이를 `추상화 레벨 통일(Single Level of Abstraction, SLA)` 이라고 한다.

예를 들어 `CoffeeMachine` 이라는 클래스를 생성한다고 가정해보자.

```kotlin
class CoffeeMachine {
	fun makeCoffe() {
		// 수백 개의 변수 선언
		// 복잡한 로직 처리
		// 낮은 수준(low level)의 최적화 진행
	}
}
```

위와 같이 하나의 함수에 저수준(low level)의 함수도 모두 포함되어 있는 형식이라면, 함수 하나가 몇 백줄이 될 것이다. 만약 이런 상태에서 `물의 온도를 수정해달라` 라는 요청이 들어온다면 개발자는 어떤 부분을 수정해야 할 지 한참을 고민하게 될 것이다.

```kotlin
class CoffeeMachine {
	fun makeCoffee() {
		boilWater()
		brewCoffee()
		pourCoffee()
		pourMilk()
	}
}
```

위와 같이 동일한 레벨의 메서드들을 만들어서 함수를 구성한다면 개발자는 해당 부분의 함수만 읽어서 문제를 해결할 수 있게 된다.

이처럼 함수는 간단해야 한다. `함수는 작아야 하며, 최소한의 책임만을 가져야 한다.` 라는 일반적인 규칙이다. 