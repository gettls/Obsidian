### 표준 라이브러리를 활용하자

다음과 같이 숫자를 특정 범위에 맞추는 간단한 알고리즘이 있다고 가정하자.

```Kotlin
val percent = when {
	numberFromUser > 100 -> 100
	numberFromUser < 0 -> 0
	else -> numberFromUser
}
```

이 알고리즘은 사실 `stdlib`의 `coerecIn` 함수로 대체할 수 있다.

`val percent = numberFromUser.coerceIn(0, 100)`

이렇게 이미 구현되어 있는 것들을 활용하면 단순히 코드가 짧아지는 것 이외에도 다양한 장점이 존재한다.

- 코드 작성 속도가 빨라진다. 
- 구현을 따로 읽지 않아도 함수의 이름만 보고도 무엇을 하는지 확실히 알 수 있다.
- 직접 구현시 발생할 수 있는 실수를 줄일 수 있다.
- 한 번만 최적화해도 함수를 활용하는 모든 곳이 최적화 혜택을 받으 수 있다.

### 나만의 유틸리티 함수 구현하기

상황에 따라 표준 라이브러리에 없는 알고리즘이 필요한 경우도 존재한다. 예를 들어 컬렉션에 있는 모든 숫자의 곱을 계산하는 라이브러리가 필요하다고 가정해보자.

```Kotlin
fun Iterable<Int>.product() =
	fold(1) { acc, i -> acc * i }
```

범용적으로 사용되는 product라는 이름을 사용했다. 동일한 결과를 얻는 함수를 여러번 만드는 것은 잘못된 일이다. 모든 함수는 테스트되어야 하고, 기억되어야 하며 유지보수 되어야 하기 때문이다. 따라서 함수를 만들기 전에는 이러한 비용이 들어갈 수 있음을 전제하고 작성되어야 한다.

코틀린의 `stdlib` 에서 정의된 대부분의 함수처럼 `product` 함수도 확장함수로 정의되었다. 많이 사용되는 알고리즘 추출 방법으로는 톱레벨 함수, 프로퍼티 위임, 클래스 등이 있는데, 확장 함수는 이러한 방법들과 비교해 다음과 같은 장점을 갖고 있다.

- 함수는 상태를 유지하지 않기 때문에 행위를 나타내기 좋다. 특히 side-effect가 없는 경우에는 더 좋다.
- 톱레벨 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있으므로 좋다.
- 수정할 객체를 아규먼트로 받아서 사용하는 것보다는 확장 리시버를 사용하는 것이 가독성 측면에서 더 뛰어나다.
- 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지기 때문에 쉽게 찾을 수 있다. 