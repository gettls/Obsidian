####  Link
- https://toss.tech/article/27600

# 주요 내용
1. Redis 과부하
2. 선착순 포인트 지급 문제 및 DB 과부하 
3. Gateway 과부하

## 1. Redis 과부하
유저 수 증가 -> Redis 데이터 / 커맨드 증가 -> Redis 과부하
- Redis 과부하는 DB의 부하로 이어질 수 있음

Redis과부하 방지를 위해서는 Caching Data와 Data R/W 시점을 체크해야 한다. 

#### Universal Data
- 모든 유저가 동일하게 사용하는 데이터
- 서버내의 Local Cache에서 캐싱해 Redis의 사용량을 줄임 -> 빠른 캐시 초기화 필요시 Redis Pub/Sub 사용
#### User-Specific Data
- 유저 특화 데이터
- 유저가 늘어나면 어쩔 수 없이 데이터 크기가 커지고 Redis 메모리 사용량이 늘어나는 문제가 생김
- 데이터를 저장할 때 압축해서 데이터 크기를 줄여서 해결
- Redis과부하로 인한 데이터 처리 장애 시의 Fallback 로직도 고려해야 함. 이 트래픽이 모두 DB로 들어간다면 DB서버에서 장애가 발생하기 때문

## 2. 선착순 포인트 지급 문제 및 DB 과부하 

선착순으로 포인트를 지급하기 위해서는 다음과 같은 네가지 고려 사항이 있었음

- 한 유저에게 포인트 중복 지급 X
- 유저에게 포인트가 지급됐다는 사실을 **즉시** 인지 해야 함
- 포인트 지급 내역을 지급 내역 원장에 기록할 수 있어야 함
- 선착순에 들지 못하면 포인트 지급 X

다음과 같은 로직으로 해결

1. 포인트 요청 API 발생 시 포인트 지급 후, 지급 내역을 저장
2. 지급 내역 저장 확인 후 분기 처리해서 중복 지급되지 않도록 구현

#### API 연속 요청 문제

포인트 요청 API가 연속으로 2개가 들어오는 경우가 발생. 이 경우 지급 내역에 저장하기 전에 포인트를 지급해버릴 수 있음. -> 포인트를 2번 지급할 수 있음

저장을 하기 전에 Redis의 RedLock을 사용해서 연속해서 요청이 들어와도 단 1번만 저장이 되도록 해결

> *RedLock ?*
> Redis에는 SETNX 커맨드가 있는데 보통 Lock을 위해 사용함. 해당 커맨드는 저장하려는 Key가 Redis에 없는 경우에만 저장에 성공함. 다만 단일 노드에서만 동작하기 때문에 Redis Cluster로 구성되어 있는 분산 환경에서는 사용하지 못함
> 
> RedLock -> Quarom 이상의 노드에서 Lock을 획득했다면 Lock을 획득한 것으로 간주함

#### 적립 내역 DB에 저장시 과부하 발생

포인트 지급 후 적립 내역을 저장하기 위해 해당 내역을 DB에 저장해야 함. 근데 적립 내역을 바로 바로 넣다보면 DB가 감당할 수 있는 QPS를 넘는 Query가 발생할 수 있음

DB와 서버 사이에 Kafka를 두고 비동기로 Insert 처리시키고, Consumer에 Throttling을 걸어서 최대 QPS에 도달하지 않도록 조절함

####  선착순 포인트 지급 문제 로직

단순하게 해결하는 방법은 다음과 같음

- Redis의 Increment Command 사용

Redis는 Single-Thread로 동작함. 따라서 Thread-safe하기 때문에 괜찮은 방법임. 하지만, Increment 커맨드가 많이 발생하면 CPU 사용량이 증가하고 Redis를 사용하는 모든 서버도 이에 영향을 받음.

Local Cache를 사용해 Counting을 하다가 특정 시점에 Redis로 Flush
-> 하지만 이 방법은 Cap를 Hard하게 준수하는 방법은 아님


### 3. Gateway 과부하

많은 트래픽은 Gateway에 부하를 줌. 특히나 암호화를 하는 Gateway는 그 부하가 더 심함.

이 경우, 중복되는 API를 줄이는 방안을 생각해볼 수 있음. 

예를 들어서 하나의 페이지에서 3개의 READ성 API를 호출하고 있다면, 이 3개의 API를 하나로 합치는 방식임


--- 

# 느낀점과 공부해야 할 점

1. API를 합치는 방식은 생각하지 못한 방법 -> 창의성이 필요한 이유..?
2. 분산 환경에서 선착순을 체크하는 방법은 어떻게 가능할까 
	- 서버의 Local cache를 이용했다고 하는데, 서버 간의 동기화는 어떻게 가능했지? -> 아마 루즈한 기준이었을듯..?
	- Redis Cluster를 사용하는 방법도 있지 않을까? -> **공부포인트**
3. DB와 서버사이에 Kafka를 활용한 방법은 신기했음
	- Kafka를 배치시켜서 쓰로틀링을 조절할 수도 있구나!
4. Redis 데이터 압축 방법도 생각해보자 -> **공부포인트**